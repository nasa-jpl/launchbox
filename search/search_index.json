{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome What is Launchbox? Launchbox is a runtime environment for web applications. It currently supports Python-based apps and static websites. Launchbox is currently a beta product. Do not use in production! What is it good for? Here are some examples of how Launchbox could be used: Add a CMS with a custom theme and let anyone in your organization create their own website from a shared codebase, no coding necessary As a local development environment, rapidly spin up local test sites with isolated databases Consolidated hosting of any number of static sites \u2013 like a self-hosted GitHub Pages kind of service How do I get started? If you have Docker installed, setting up a local environment to test out Launchbox is a breeze. Check out our setup guide to get it going. View the Core Concepts page to learn the basics of how Launchbox works and how you can set up your own site or application to run on it. Get the code View repo","title":"Welcome"},{"location":"#welcome","text":"","title":"Welcome"},{"location":"#what-is-launchbox","text":"Launchbox is a runtime environment for web applications. It currently supports Python-based apps and static websites. Launchbox is currently a beta product. Do not use in production!","title":"What is Launchbox?"},{"location":"#what-is-it-good-for","text":"Here are some examples of how Launchbox could be used: Add a CMS with a custom theme and let anyone in your organization create their own website from a shared codebase, no coding necessary As a local development environment, rapidly spin up local test sites with isolated databases Consolidated hosting of any number of static sites \u2013 like a self-hosted GitHub Pages kind of service","title":"What is it good for?"},{"location":"#how-do-i-get-started","text":"If you have Docker installed, setting up a local environment to test out Launchbox is a breeze. Check out our setup guide to get it going. View the Core Concepts page to learn the basics of how Launchbox works and how you can set up your own site or application to run on it.","title":"How do I get started?"},{"location":"#get-the-code","text":"View repo","title":"Get the code"},{"location":"concepts/","text":"Core Concepts Launchbox provides a platform for running one or more services , each of which may have multiple tenant sites that belong to it. Services can provide resources to their sites (such as databases, caches, or object storage) and utilize plugins to provide shared infrastructure to them. Launchbox also has a built-in Management Dashboard , a web app that provides a UI for managing sites and services. Let's look at each of these in some more detail. Services Services are the heart of Launchbox. In concrete terms, a service is any Git repository that provides a website \u2013 whether that's a collection of static files or a database-backed application \u2013 that Launchbox can clone and use to spin up a website. Turning an existing repository into a Launchbox service can be as simple as adding a launch.yaml file that tells Launchbox how to configure and run the service. When a service is deployed for the first time or a new deployment is triggered to update the service code, Launchbox will look at launch.yaml and do two things: (1) set up any resources its sites may need, and (2) run any necessary commands specified in the setup phase, such as migrating database schemas. Services can be used to create one or more sites that Launchbox will serve. In cases where a service requires a database or other resources, the application code will also need to be modified to use a different database for each site that uses the service. For more details, see the Services page . Sites A site is a single instance of a service, available at a unique hostname. It may be the only instance of a service (for example, a static documentation page), or it may be one of hundreds (for example, an internal department site backed by a CMS). Sites are created and managed on the Management Dashboard, where you can choose a service to use, assign a hostname, and more, depending on what kind of service it uses. Resources A Launchbox service's launch.yaml file can be configured to create resources for each site that uses the service. The three kinds of resources offered are: Databases (currently supporting PostgreSQL) Caches (currently supporting Redis) Storage (currently supporting Amazon S3, or services that follow S3 API) For more details, see the Resources page . Plugins Launchbox operators can install plugins to help services and sites integrate with providers of things like identity, authentication, and SSL certificates. For example, at JPL we have closed-source plugins that connect Launchbox to our LDAP directory, SAML single-sign-on service, and internal SSL certificate generator. For more details, see the Plugins page . The Management Dashboard Running locally on http://launchbox.run:8080 , this dashboard is where you can add and manage services, sites, and plugins. (insert image of dashboard homepage) Additional description TK","title":"Core Concepts"},{"location":"concepts/#core-concepts","text":"Launchbox provides a platform for running one or more services , each of which may have multiple tenant sites that belong to it. Services can provide resources to their sites (such as databases, caches, or object storage) and utilize plugins to provide shared infrastructure to them. Launchbox also has a built-in Management Dashboard , a web app that provides a UI for managing sites and services. Let's look at each of these in some more detail.","title":"Core Concepts"},{"location":"concepts/#services","text":"Services are the heart of Launchbox. In concrete terms, a service is any Git repository that provides a website \u2013 whether that's a collection of static files or a database-backed application \u2013 that Launchbox can clone and use to spin up a website. Turning an existing repository into a Launchbox service can be as simple as adding a launch.yaml file that tells Launchbox how to configure and run the service. When a service is deployed for the first time or a new deployment is triggered to update the service code, Launchbox will look at launch.yaml and do two things: (1) set up any resources its sites may need, and (2) run any necessary commands specified in the setup phase, such as migrating database schemas. Services can be used to create one or more sites that Launchbox will serve. In cases where a service requires a database or other resources, the application code will also need to be modified to use a different database for each site that uses the service. For more details, see the Services page .","title":"Services"},{"location":"concepts/#sites","text":"A site is a single instance of a service, available at a unique hostname. It may be the only instance of a service (for example, a static documentation page), or it may be one of hundreds (for example, an internal department site backed by a CMS). Sites are created and managed on the Management Dashboard, where you can choose a service to use, assign a hostname, and more, depending on what kind of service it uses.","title":"Sites"},{"location":"concepts/#resources","text":"A Launchbox service's launch.yaml file can be configured to create resources for each site that uses the service. The three kinds of resources offered are: Databases (currently supporting PostgreSQL) Caches (currently supporting Redis) Storage (currently supporting Amazon S3, or services that follow S3 API) For more details, see the Resources page .","title":"Resources"},{"location":"concepts/#plugins","text":"Launchbox operators can install plugins to help services and sites integrate with providers of things like identity, authentication, and SSL certificates. For example, at JPL we have closed-source plugins that connect Launchbox to our LDAP directory, SAML single-sign-on service, and internal SSL certificate generator. For more details, see the Plugins page .","title":"Plugins"},{"location":"concepts/#the-management-dashboard","text":"Running locally on http://launchbox.run:8080 , this dashboard is where you can add and manage services, sites, and plugins. (insert image of dashboard homepage) Additional description TK","title":"The Management Dashboard"},{"location":"setup/","text":"Getting Started Launchbox is primarily developed on macOS systems and is used on Ubuntu container images in the cloud. We are open to supporting other operating systems; please review our contribution guidelines if you would like to help add that support! Requirements If you're running on macOS, the only real requirement that isn't preinstalled is Docker . Steps Clone the Launchbox repo: git clone https://github.com/nasa-jpl/launchbox Enter the newly created launchbox folder: cd launchbox Setup your .env file: cp .env.dist .env Update or add to .env as needed. In particular, if you intend to use any private repositories as the source for a service, you will need to create a Personal Access Token and set GIT_TOKEN to that. Build the Docker container: make devbuild Start the Docker container: make start In a new terminal, open the Launchbox dashboard: make dashboard Install our demo service: Go to the Services section of the dashboard and click the New Service button Enter the following: Service Identifier: demo Service Name: Launchbox Demo Repo URL: https://github.com/nasa-jpl/launchbox-demo-service Branch: main Environment Name: development Click the Create button On the new row in the All Services table, click the View button on the right Click the Deployments tab Click the Deploy button on the right of the top row Go to the Deploys section, wait a minute or so, and refresh a few times until you see that the deployment you just triggered is complete Tip: You can also click the deployment's View button to see the progress of individual deployment steps. (This page auto-refreshes.) Create a site using the demo service: Go to the Sites section and click the New Site button Give it a Site Identifier , choose the demo service, and click the Create button On the new row in the All Sites table, click the View button on the right Click the Hostnames tab In the new hostname field, enter demo.launchbox.run , then click Add Hostname Click the link that appears in the Hostname column in the new row to open the demo site in a new tab","title":"Getting Started"},{"location":"setup/#getting-started","text":"Launchbox is primarily developed on macOS systems and is used on Ubuntu container images in the cloud. We are open to supporting other operating systems; please review our contribution guidelines if you would like to help add that support!","title":"Getting Started"},{"location":"setup/#requirements","text":"If you're running on macOS, the only real requirement that isn't preinstalled is Docker .","title":"Requirements"},{"location":"setup/#steps","text":"Clone the Launchbox repo: git clone https://github.com/nasa-jpl/launchbox Enter the newly created launchbox folder: cd launchbox Setup your .env file: cp .env.dist .env Update or add to .env as needed. In particular, if you intend to use any private repositories as the source for a service, you will need to create a Personal Access Token and set GIT_TOKEN to that. Build the Docker container: make devbuild Start the Docker container: make start In a new terminal, open the Launchbox dashboard: make dashboard Install our demo service: Go to the Services section of the dashboard and click the New Service button Enter the following: Service Identifier: demo Service Name: Launchbox Demo Repo URL: https://github.com/nasa-jpl/launchbox-demo-service Branch: main Environment Name: development Click the Create button On the new row in the All Services table, click the View button on the right Click the Deployments tab Click the Deploy button on the right of the top row Go to the Deploys section, wait a minute or so, and refresh a few times until you see that the deployment you just triggered is complete Tip: You can also click the deployment's View button to see the progress of individual deployment steps. (This page auto-refreshes.) Create a site using the demo service: Go to the Sites section and click the New Site button Give it a Site Identifier , choose the demo service, and click the Create button On the new row in the All Sites table, click the View button on the right Click the Hostnames tab In the new hostname field, enter demo.launchbox.run , then click Add Hostname Click the link that appears in the Hostname column in the new row to open the demo site in a new tab","title":"Steps"},{"location":"features/plugins/","text":"Plugins TK","title":"Plugins"},{"location":"features/plugins/#plugins","text":"TK","title":"Plugins"},{"location":"features/resources/","text":"Resources A Launchbox service's launch.yaml file can be configured to create resources for each site that uses the service. You specify what resources your application requires and configuration details will be provided to each site via environment variables. The three kinds of resources offered are: Databases (currently supporting PostgreSQL) Caches (currently supporting Redis) Storage (currently supporting Amazon S3, or services that follow S3 API) Configuration In your launch.yaml file, add a top-level resources object with a number of resource objects that are named with an identifier of your choosing. Each entry must have a type property, which can be either postgres , redis , or s3 . You can specify multiple resources of the same type, if needed. Example ... resources : database1 : type : postgres database2 : type : postgres cache1 : type : redis storage1 : type : s3 ... Usage When Launchbox encounters the resources object in the launch.yaml file of a service or site it's deploying, it will create those services (or verify that they are already present) and create the environment variables that are unique to each site. Given the example configuration above, each site using this service would be given the following variables: Postgres databases: LB_database1_type LB_database1_hostname LB_database1_port LB_database1_name LB_database1_username LB_database1_password LB_database2_type LB_database2_hostname LB_database1_port LB_database2_name LB_database2_username LB_database2_password Redis cache: LB_cache1_type LB_cache1_url LB_cache1_prefix S3 storage: LB_storage1_type LB_storage1_bucket Service applications can then use these environment variables in their code to ensure that each site can access its own individual resources. For example, a Django application would want to set its DATABASES setting like so: DATABASES = { \"default\" : { \"ENGINE\" : \"django.db.backends.postgresql\" , \"HOST\" : os . environ . get ( \"LB_database1_hostname\" ), \"PORT\" : os . environ . get ( \"LB_database1_port\" ), \"NAME\" : os . environ . get ( \"LB_database1_name\" ), \"USER\" : os . environ . get ( \"LB_database1_username\" ), \"PASSWORD\" : os . environ . get ( \"LB_database1_password\" ), }, } Tip Django users \u2013 for even easier integration with Django, check out our django-launchbox helper package! Additional notes For services where postgresql resources are configured, Launchbox will create a separate database for each site that uses the service. For services where s3 resources are configured, Launchbox will create a separate bucket for each site that uses the service.","title":"Resources"},{"location":"features/resources/#resources","text":"A Launchbox service's launch.yaml file can be configured to create resources for each site that uses the service. You specify what resources your application requires and configuration details will be provided to each site via environment variables. The three kinds of resources offered are: Databases (currently supporting PostgreSQL) Caches (currently supporting Redis) Storage (currently supporting Amazon S3, or services that follow S3 API)","title":"Resources"},{"location":"features/resources/#configuration","text":"In your launch.yaml file, add a top-level resources object with a number of resource objects that are named with an identifier of your choosing. Each entry must have a type property, which can be either postgres , redis , or s3 . You can specify multiple resources of the same type, if needed.","title":"Configuration"},{"location":"features/resources/#example","text":"... resources : database1 : type : postgres database2 : type : postgres cache1 : type : redis storage1 : type : s3 ...","title":"Example"},{"location":"features/resources/#usage","text":"When Launchbox encounters the resources object in the launch.yaml file of a service or site it's deploying, it will create those services (or verify that they are already present) and create the environment variables that are unique to each site. Given the example configuration above, each site using this service would be given the following variables: Postgres databases: LB_database1_type LB_database1_hostname LB_database1_port LB_database1_name LB_database1_username LB_database1_password LB_database2_type LB_database2_hostname LB_database1_port LB_database2_name LB_database2_username LB_database2_password Redis cache: LB_cache1_type LB_cache1_url LB_cache1_prefix S3 storage: LB_storage1_type LB_storage1_bucket Service applications can then use these environment variables in their code to ensure that each site can access its own individual resources. For example, a Django application would want to set its DATABASES setting like so: DATABASES = { \"default\" : { \"ENGINE\" : \"django.db.backends.postgresql\" , \"HOST\" : os . environ . get ( \"LB_database1_hostname\" ), \"PORT\" : os . environ . get ( \"LB_database1_port\" ), \"NAME\" : os . environ . get ( \"LB_database1_name\" ), \"USER\" : os . environ . get ( \"LB_database1_username\" ), \"PASSWORD\" : os . environ . get ( \"LB_database1_password\" ), }, } Tip Django users \u2013 for even easier integration with Django, check out our django-launchbox helper package!","title":"Usage"},{"location":"features/resources/#additional-notes","text":"For services where postgresql resources are configured, Launchbox will create a separate database for each site that uses the service. For services where s3 resources are configured, Launchbox will create a separate bucket for each site that uses the service.","title":"Additional notes"},{"location":"features/services/","text":"Services Services are the heart of Launchbox. In concrete terms, a service is any Git repository that provides a website \u2013 whether that's a collection of static files or a database-backed application \u2013 that Launchbox can clone and use to spin up a website. Turning an existing repository into a Launchbox service can be as simple as adding a launch.yaml file that tells Launchbox how to configure and run the service. In the simplest case \u2013 a static site with no build process and the index.html file at the root of the repository \u2013 here's what a minimal launch.yaml would look like: routes : site : route : / type : static A dynamic, database-backed application would have a more extensive launch.yaml , like this example that configures the Wagtail Bakery demo site : env : base : DEBUG : true UWSGI_WSGI_FILE : bakerydemo/wsgi.py DJANGO_SETTINGS_MODULE : bakerydemo.settings.local # specific environments (augments/overrides base) production : DEBUG : false resources : database : type : postgres cache : type : redis storage : type : s3 phases : setup : - pip3 install -r requirements/production.txt - cp bakerydemo/settings/local.py.example bakerydemo/settings/local.py - echo \"DJANGO_SETTINGS_MODULE=bakerydemo.settings.local\" > .env tenant : - python3 manage.py migrate --noinput routes : site : route : / type : wsgi options : path : bakerydemo/wsgi.py var : application Q FOR THE GROUP: phases.setup is the only thing that happens on service deployment, right? Everything else happens on site deployment? Given that, would it make any sense to pull out setup and tenant to the top level, and move setup to the top of the file, to better mirror the order of operations? launch.yaml spec Q FOR THE GROUP: This is a \"narrative\" sort of spec. Should we have something more formalized? env Creates environment variables with the specified values for each of this service's sites. The base grouping is required for variables that should exist in all Launchbox environments. Additional groupings can be created that will trigger creation of other environment variables (or redefinition of base environment variables) when Launchbox's environment matches the name of that grouping. For example, given the env configuration: env : base : DEBUG : true UWSGI_WSGI_FILE : bakerydemo/wsgi.py DJANGO_SETTINGS_MODULE : bakerydemo.settings.local # specific environments (augments/overrides base) production : DEBUG : false if the environment variable named ENVIRONMENT is set to production where Launchbox is running, sites created for this service will have their DEBUG environment variables set to false instead of true . resources Creates infrastructure resources for each of this services sites. resources : database1 : type : postgres cache1 : type : redis storage1 : type : s3 Within the resources section, create objects with your identifier of choice (like database1 above) for each resource you need. Each must have a type property that tells Launchbox what kind of resource to create. The three kinds of resources offered are: Databases (currently supporting PostgreSQL) Caches (currently supporting Redis) Storage (currently supporting Amazon S3, or services that follow S3 API) For more details on resource usage, see the Resources page . phases The phases section is used to specify commands that should be run on service and site deployments. phases : setup : - pip3 install -r requirements/production.txt - cp bakerydemo/settings/local.py.example bakerydemo/settings/local.py - echo \"DJANGO_SETTINGS_MODULE=bakerydemo.settings.local\" > .env tenant : - python3 manage.py migrate --noinput Commands given in the setup subsection will be run after a service repository is cloned (both the first time and when it is updated), from that service's folder on the container filesystem. Commands given in the tenant subsection will be run each time one of this service's sites is deployed (or redeployed). Tip Python services are automatically given their own virtual environment that both setup and tenant commands are run from, so feel free to install whatever packages you require directly. Both setup and tenant sections are not required; some services may only need one or the other. routes The routes section tells Launchbox how NGINX should route traffic to this service. It is the only required section of the launch.yaml file. Services can have multiple routes, if needed. routes : api : route : / type : wsgi options : path : app/api.py var : app pages : route : /pages/ type : static options : path : pages assets : route : /static/data.json type : static options : path : static/data.json Each child object of routes can be named with an identifier of your choice. Within each, there are three required properties: route (the path under the hostname), type (either wsgi or static ), and options . If type is wsgi , options.path should point to the Python module where the WSGI application is initialized and options.var should be the variable that application is assigned to inside that module. If type is static , options.path should point to the location (in the repository) of the file/folder you want to serve (at the route given above).","title":"Services"},{"location":"features/services/#services","text":"Services are the heart of Launchbox. In concrete terms, a service is any Git repository that provides a website \u2013 whether that's a collection of static files or a database-backed application \u2013 that Launchbox can clone and use to spin up a website. Turning an existing repository into a Launchbox service can be as simple as adding a launch.yaml file that tells Launchbox how to configure and run the service. In the simplest case \u2013 a static site with no build process and the index.html file at the root of the repository \u2013 here's what a minimal launch.yaml would look like: routes : site : route : / type : static A dynamic, database-backed application would have a more extensive launch.yaml , like this example that configures the Wagtail Bakery demo site : env : base : DEBUG : true UWSGI_WSGI_FILE : bakerydemo/wsgi.py DJANGO_SETTINGS_MODULE : bakerydemo.settings.local # specific environments (augments/overrides base) production : DEBUG : false resources : database : type : postgres cache : type : redis storage : type : s3 phases : setup : - pip3 install -r requirements/production.txt - cp bakerydemo/settings/local.py.example bakerydemo/settings/local.py - echo \"DJANGO_SETTINGS_MODULE=bakerydemo.settings.local\" > .env tenant : - python3 manage.py migrate --noinput routes : site : route : / type : wsgi options : path : bakerydemo/wsgi.py var : application Q FOR THE GROUP: phases.setup is the only thing that happens on service deployment, right? Everything else happens on site deployment? Given that, would it make any sense to pull out setup and tenant to the top level, and move setup to the top of the file, to better mirror the order of operations?","title":"Services"},{"location":"features/services/#launchyaml-spec","text":"Q FOR THE GROUP: This is a \"narrative\" sort of spec. Should we have something more formalized?","title":"launch.yaml spec"},{"location":"features/services/#env","text":"Creates environment variables with the specified values for each of this service's sites. The base grouping is required for variables that should exist in all Launchbox environments. Additional groupings can be created that will trigger creation of other environment variables (or redefinition of base environment variables) when Launchbox's environment matches the name of that grouping. For example, given the env configuration: env : base : DEBUG : true UWSGI_WSGI_FILE : bakerydemo/wsgi.py DJANGO_SETTINGS_MODULE : bakerydemo.settings.local # specific environments (augments/overrides base) production : DEBUG : false if the environment variable named ENVIRONMENT is set to production where Launchbox is running, sites created for this service will have their DEBUG environment variables set to false instead of true .","title":"env"},{"location":"features/services/#resources","text":"Creates infrastructure resources for each of this services sites. resources : database1 : type : postgres cache1 : type : redis storage1 : type : s3 Within the resources section, create objects with your identifier of choice (like database1 above) for each resource you need. Each must have a type property that tells Launchbox what kind of resource to create. The three kinds of resources offered are: Databases (currently supporting PostgreSQL) Caches (currently supporting Redis) Storage (currently supporting Amazon S3, or services that follow S3 API) For more details on resource usage, see the Resources page .","title":"resources"},{"location":"features/services/#phases","text":"The phases section is used to specify commands that should be run on service and site deployments. phases : setup : - pip3 install -r requirements/production.txt - cp bakerydemo/settings/local.py.example bakerydemo/settings/local.py - echo \"DJANGO_SETTINGS_MODULE=bakerydemo.settings.local\" > .env tenant : - python3 manage.py migrate --noinput Commands given in the setup subsection will be run after a service repository is cloned (both the first time and when it is updated), from that service's folder on the container filesystem. Commands given in the tenant subsection will be run each time one of this service's sites is deployed (or redeployed). Tip Python services are automatically given their own virtual environment that both setup and tenant commands are run from, so feel free to install whatever packages you require directly. Both setup and tenant sections are not required; some services may only need one or the other.","title":"phases"},{"location":"features/services/#routes","text":"The routes section tells Launchbox how NGINX should route traffic to this service. It is the only required section of the launch.yaml file. Services can have multiple routes, if needed. routes : api : route : / type : wsgi options : path : app/api.py var : app pages : route : /pages/ type : static options : path : pages assets : route : /static/data.json type : static options : path : static/data.json Each child object of routes can be named with an identifier of your choice. Within each, there are three required properties: route (the path under the hostname), type (either wsgi or static ), and options . If type is wsgi , options.path should point to the Python module where the WSGI application is initialized and options.var should be the variable that application is assigned to inside that module. If type is static , options.path should point to the location (in the repository) of the file/folder you want to serve (at the route given above).","title":"routes"},{"location":"reference/api-routes/","text":"API Routes .topbar { display: none !important; } .info { display: none !important; } .scheme-container { display: none !important; } .response-col_description__inner { margin-top: -15px; } .response-col_links { display: none; } window.onload = function() { // Begin Swagger UI call region const ui = SwaggerUIBundle({ url: \"../api-spec.yaml\", dom_id: '#swagger-ui', deepLinking: false, presets: [ SwaggerUIBundle.presets.apis, SwaggerUIStandalonePreset ], layout: \"StandaloneLayout\", supportedSubmitMethods: [], validatorUrl: null, }); // End Swagger UI call region window.ui = ui; };","title":"API Routes"},{"location":"reference/api-routes/#api-routes","text":".topbar { display: none !important; } .info { display: none !important; } .scheme-container { display: none !important; } .response-col_description__inner { margin-top: -15px; } .response-col_links { display: none; } window.onload = function() { // Begin Swagger UI call region const ui = SwaggerUIBundle({ url: \"../api-spec.yaml\", dom_id: '#swagger-ui', deepLinking: false, presets: [ SwaggerUIBundle.presets.apis, SwaggerUIStandalonePreset ], layout: \"StandaloneLayout\", supportedSubmitMethods: [], validatorUrl: null, }); // End Swagger UI call region window.ui = ui; };","title":"API Routes"},{"location":"reference/dashboard-routes/","text":"Dashboard Routes Auth - /auth/login - /auth/logout Home # Overview - / API Spec # Display API spec - /spec Deploys # List all deploys - /deploys Services # List all services - /services # Add service - /add/service # View service - /services/<service_id> - /services/<service_id>/deploys - /services/<service_id>/events - /services/<service_id>/manage Settings # Basic settings - /settings # Plugins (Auth, Identity, etc) - /settings/plugins - /add/plugin # Providers (connect Github, etc) - /settings/providers - /add/provider Sites # List all sites - /sites # Add site - /add/site # View site - /sites/<site_id> - /sites/<site_id>/events - /sites/<site_id>/hostnames - /sites/<site_id>/notes - /sites/<site_id>/resources - /sites/<site_id>/manage Status # View cluster status - /status/overview - /status/advanced","title":"Dashboard Routes"},{"location":"reference/dashboard-routes/#dashboard-routes","text":"Auth - /auth/login - /auth/logout Home # Overview - / API Spec # Display API spec - /spec Deploys # List all deploys - /deploys Services # List all services - /services # Add service - /add/service # View service - /services/<service_id> - /services/<service_id>/deploys - /services/<service_id>/events - /services/<service_id>/manage Settings # Basic settings - /settings # Plugins (Auth, Identity, etc) - /settings/plugins - /add/plugin # Providers (connect Github, etc) - /settings/providers - /add/provider Sites # List all sites - /sites # Add site - /add/site # View site - /sites/<site_id> - /sites/<site_id>/events - /sites/<site_id>/hostnames - /sites/<site_id>/notes - /sites/<site_id>/resources - /sites/<site_id>/manage Status # View cluster status - /status/overview - /status/advanced","title":"Dashboard Routes"},{"location":"reference/deployment-schema/","text":"Deployment Schema deployment represents each deployment attempt schema: unique identifier: deployment_id (UUID) attrs: service_id -> service commit_sha","title":"Deployment Schema"},{"location":"reference/deployment-schema/#deployment-schema","text":"deployment represents each deployment attempt schema: unique identifier: deployment_id (UUID) attrs: service_id -> service commit_sha","title":"Deployment Schema"},{"location":"reference/launch.yaml-schema/","text":"launch.yaml Schema TK","title":"launch.yaml Schema"},{"location":"reference/launch.yaml-schema/#launchyaml-schema","text":"TK","title":"launch.yaml Schema"}]}